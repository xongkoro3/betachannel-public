"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNodeName = getNodeName;
exports.scopeHasLocalReference = exports.getStringValue = exports.hasExpressions = exports.isStringNode = exports.isTemplateLiteral = exports.isStringLiteral = exports.isLiteralNode = exports.isDescribe = exports.isTestCase = exports.isHook = exports.isFunction = exports.TestCaseProperty = exports.DescribeProperty = exports.HookName = exports.TestCaseName = exports.DescribeAlias = exports.isExpectCallWithParent = exports.isExpectCall = exports.createRule = void 0;

var _path = require("path");

var _experimentalUtils = require("@typescript-eslint/experimental-utils");

var _package = require("../../package.json");

// TODO: rename to utils.ts when TS migration is complete
const REPO_URL = 'https://github.com/jest-community/eslint-plugin-jest';

const createRule = _experimentalUtils.ESLintUtils.RuleCreator(name => {
  const ruleName = (0, _path.basename)(name, '.ts');
  return `${REPO_URL}/blob/v${_package.version}/docs/rules/${ruleName}.md`;
});

exports.createRule = createRule;

/**
 * Checks if the given `node` is considered a {@link JestExpectIdentifier}.
 *
 * A `node` is considered to be as such if it is of type `Identifier`,
 * and `name`d `"expect"`.
 *
 * @param {Node} node
 *
 * @return {node is JestExpectIdentifier}
 */
const isExpectIdentifier = node => node.type === _experimentalUtils.AST_NODE_TYPES.Identifier && node.name === 'expect'; // represents "expect()" specifically


/**
 * Checks if the given `node` is a {@link JestExpectCallExpression}.
 *
 * @param {Node} node
 *
 * @return {node is JestExpectCallExpression}
 */
const isExpectCall = node => node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && isExpectIdentifier(node.callee);

exports.isExpectCall = isExpectCall;

const isExpectCallWithParent = node => isExpectCall(node) && node.parent !== undefined && node.parent.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && node.parent.property.type === _experimentalUtils.AST_NODE_TYPES.Identifier;

exports.isExpectCallWithParent = isExpectCallWithParent;
let DescribeAlias;
exports.DescribeAlias = DescribeAlias;

(function (DescribeAlias) {
  DescribeAlias["describe"] = "describe";
  DescribeAlias["fdescribe"] = "fdescribe";
  DescribeAlias["xdescribe"] = "xdescribe";
})(DescribeAlias || (exports.DescribeAlias = DescribeAlias = {}));

let TestCaseName;
exports.TestCaseName = TestCaseName;

(function (TestCaseName) {
  TestCaseName["fit"] = "fit";
  TestCaseName["it"] = "it";
  TestCaseName["test"] = "test";
  TestCaseName["xit"] = "xit";
  TestCaseName["xtest"] = "xtest";
})(TestCaseName || (exports.TestCaseName = TestCaseName = {}));

let HookName;
exports.HookName = HookName;

(function (HookName) {
  HookName["beforeAll"] = "beforeAll";
  HookName["beforeEach"] = "beforeEach";
  HookName["afterAll"] = "afterAll";
  HookName["afterEach"] = "afterEach";
})(HookName || (exports.HookName = HookName = {}));

let DescribeProperty;
exports.DescribeProperty = DescribeProperty;

(function (DescribeProperty) {
  DescribeProperty["each"] = "each";
  DescribeProperty["only"] = "only";
  DescribeProperty["skip"] = "skip";
})(DescribeProperty || (exports.DescribeProperty = DescribeProperty = {}));

let TestCaseProperty;
exports.TestCaseProperty = TestCaseProperty;

(function (TestCaseProperty) {
  TestCaseProperty["each"] = "each";
  TestCaseProperty["only"] = "only";
  TestCaseProperty["skip"] = "skip";
  TestCaseProperty["todo"] = "todo";
})(TestCaseProperty || (exports.TestCaseProperty = TestCaseProperty = {}));

function getNodeName(node) {
  function joinNames(a, b) {
    return a && b ? `${a}.${b}` : null;
  }

  switch (node.type) {
    case _experimentalUtils.AST_NODE_TYPES.Identifier:
      return node.name;

    case _experimentalUtils.AST_NODE_TYPES.Literal:
      return `${node.value}`;

    case _experimentalUtils.AST_NODE_TYPES.TemplateLiteral:
      if (node.expressions.length === 0) return node.quasis[0].value.cooked;
      break;

    case _experimentalUtils.AST_NODE_TYPES.MemberExpression:
      return joinNames(getNodeName(node.object), getNodeName(node.property));
  }

  return null;
}

const isFunction = node => node.type === _experimentalUtils.AST_NODE_TYPES.FunctionExpression || node.type === _experimentalUtils.AST_NODE_TYPES.ArrowFunctionExpression;

exports.isFunction = isFunction;

const isHook = node => {
  return node.callee.type === _experimentalUtils.AST_NODE_TYPES.Identifier && HookName.hasOwnProperty(node.callee.name);
};

exports.isHook = isHook;

const isTestCase = node => {
  return node.callee.type === _experimentalUtils.AST_NODE_TYPES.Identifier && TestCaseName.hasOwnProperty(node.callee.name) || node.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && node.callee.object.type === _experimentalUtils.AST_NODE_TYPES.Identifier && TestCaseName.hasOwnProperty(node.callee.object.name) && node.callee.property.type === _experimentalUtils.AST_NODE_TYPES.Identifier && TestCaseProperty.hasOwnProperty(node.callee.property.name);
};

exports.isTestCase = isTestCase;

const isDescribe = node => {
  return node.callee.type === _experimentalUtils.AST_NODE_TYPES.Identifier && DescribeAlias.hasOwnProperty(node.callee.name) || node.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && node.callee.object.type === _experimentalUtils.AST_NODE_TYPES.Identifier && DescribeAlias.hasOwnProperty(node.callee.object.name) && node.callee.property.type === _experimentalUtils.AST_NODE_TYPES.Identifier && DescribeProperty.hasOwnProperty(node.callee.property.name);
};

exports.isDescribe = isDescribe;

const isLiteralNode = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal;

exports.isLiteralNode = isLiteralNode;

const isStringLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'string';

exports.isStringLiteral = isStringLiteral;

const isTemplateLiteral = node => node && node.type === _experimentalUtils.AST_NODE_TYPES.TemplateLiteral;

exports.isTemplateLiteral = isTemplateLiteral;

const isStringNode = node => node !== undefined && (isStringLiteral(node) || isTemplateLiteral(node));

exports.isStringNode = isStringNode;

const hasExpressions = node => 'expressions' in node && node.expressions.length > 0;
/* istanbul ignore next we'll need this later */


exports.hasExpressions = hasExpressions;

const getStringValue = arg => isTemplateLiteral(arg) ? arg.quasis[0].value.raw : arg.value;

exports.getStringValue = getStringValue;

const collectReferences = scope => {
  const locals = new Set();
  const unresolved = new Set();
  let currentScope = scope;

  while (currentScope !== null) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = currentScope.variables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const ref = _step.value;
        const isReferenceDefined = ref.defs.some(def => {
          return def.type !== 'ImplicitGlobalVariable';
        });

        if (isReferenceDefined) {
          locals.add(ref.name);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = currentScope.through[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        const ref = _step2.value;
        unresolved.add(ref.identifier.name);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    currentScope = currentScope.upper;
  }

  return {
    locals,
    unresolved
  };
};

const scopeHasLocalReference = (scope, referenceName) => {
  const references = collectReferences(scope);
  return (// referenceName was found as a local variable or function declaration.
    references.locals.has(referenceName) || // referenceName was not found as an unresolved reference,
    // meaning it is likely not an implicit global reference.
    !references.unresolved.has(referenceName)
  );
};

exports.scopeHasLocalReference = scopeHasLocalReference;